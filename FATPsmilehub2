local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local TweenService = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Debris = game:GetService("Debris")
local LP = Players.LocalPlayer
local UIS = game:GetService("UserInputService")

-- 新しいUIライブラリのロード
local OrionLib = loadstring(game:HttpGet("https://raw.githubusercontent.com/jadpy/suki/refs/heads/main/orion"))()

-- ====================================================================
-- GLOBAL/SHARED VARIABLES (線香花火用)
-- ====================================================================
local IsGeometricActive = false
local GeometricTargetName = "Sparkler"
local CurrentPattern = "Circle"
local Radius = 10
local HeightOffset = 5
local RotationSpeed = 1000
local GeometricList = {}
local geometricLoopConn = nil
local tAccum = 0

-- ====================================================================
-- GLOBAL/SHARED VARIABLES (羽モーション用)
-- ====================================================================
local IsWingActive = false
local WingTargetName = "Sparkler"
local WingRadius = 10
local WingHeightOffset = 5
local WingSpeed = 1000
local WingSpread = 10
local WingList = {}
local wingLoopConn = nil

-- ====================================================================
-- GLOBAL/SHARED VARIABLES (サイレントエイム用)
-- ====================================================================
local SilentAimEnabled = false
local SilentAimRange = 30
local oldNamecall = nil

-- ====================================================================
-- GLOBAL/SHARED VARIABLES (Egg Hub機能)
-- ====================================================================
local EggConfig = {
    Grab = { 
        KickGrab = false, 
        KillGrab = false, 
        VoidGrab = false, 
        AnchorGrab = false,
        ThrowPower = 250
    },
    Defense = { 
        AntiGrab = false, 
        AntiVoid = false, 
        AntiExplode = false, 
        AntiRagdoll = false, 
        AntiGucci = false 
    },
    Camera = {
        MaxZoom = 128,
        SuperZoom = false
    }
}

local EggDefenseTimer = 0

-- レインボーUI用
local rainbowHue = 0
local orionGuiName = nil

-- ====================================================================
-- UTILITY FUNCTIONS (共通)
-- ====================================================================
local function LocalHRP()
    local c = LP and LP.Character or nil
    if not c then return nil end
    return c:FindFirstChild("HumanoidRootPart")
end

local function getHum() 
    local c = LP.Character 
    if not c then return nil end 
    return c:FindFirstChildOfClass("Humanoid") 
end

local function attachPhysics(p)
    if not p or not p.Parent then return nil, nil end
    pcall(function() p:SetNetworkOwner(LP) end)

    p.CanCollide = false
    p.CanTouch = false
    p.CanQuery = false
    p.Massless = true

    p.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
    p.AssemblyAngularVelocity = Vector3.new(0, 0, 0)

    local bp = p:FindFirstChild("BodyPosition") or Instance.new("BodyPosition")
    if not bp.Parent then
        bp.Name = "BodyPosition"
        bp.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
        bp.P = 3e6
        bp.D = 2000
        bp.Position = p.Position
        bp.Parent = p
    end
    local bg = p:FindFirstChild("BodyGyro") or Instance.new("BodyGyro")
    if not bg.Parent then
        bg.Name = "BodyGyro"
        bg.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
        bg.P = 3e6
        bg.D = 1000
        bg.CFrame = p.CFrame
        bg.Parent = p
    end

    return bp, bg
end

local function detachPhysics(p)
    if not p or not p.Parent then return end
    local bp = p:FindFirstChild("BodyPosition"); if bp then bp:Destroy() end
    local bg = p:FindFirstChild("BodyGyro"); if bg then bg:Destroy() end

    p.CanCollide = true
    p.CanTouch = true
    p.CanQuery = true
    p.Massless = false
    pcall(function() p:SetNetworkOwner(nil) end)
end

-- ====================================================================
-- SILENT AIM FUNCTIONS (追加)
-- ====================================================================
local function GetDirection(Origin, Position)
    return (Position - Origin).Unit * (Origin - Position).Magnitude
end

local function GetClosestPlayerInWorld()
    local Closest, Distance = nil, SilentAimRange
    local hrp = LocalHRP()
    if not hrp then return nil end

    for _, Player in pairs(Players:GetPlayers()) do
        if Player ~= LP then
            local Character = Player.Character
            local Head = Character and Character:FindFirstChild("Head")
            local Humanoid = Character and Character:FindFirstChild("Humanoid")

            if Head and (Humanoid and Humanoid.Health > 0) then
                local _Distance = (hrp.Position - Head.Position).Magnitude
                if _Distance <= Distance then
                    Closest = Head
                    Distance = _Distance
                end
            end
        end
    end
    return Closest
end

local function HookSilentAim()
    if oldNamecall then return end
    
    oldNamecall = hookmetamethod(game, "__namecall", function(...)
        local Method = getnamecallmethod()
        local Arguments = {...}
        
        if SilentAimEnabled and Arguments[1] == workspace and Method == "Raycast" then
            if typeof(Arguments[#Arguments]) ~= "RaycastParams" then
                return oldNamecall(...)
            end
            
            local HitPart = GetClosestPlayerInWorld()
            
            if HitPart then
                Arguments[3] = GetDirection(Arguments[2], HitPart.Position)
                return oldNamecall(unpack(Arguments))
            end
        end
        return oldNamecall(...)
    end)
end

-- ====================================================================
-- EGG HUB UTILITY FUNCTIONS
-- ====================================================================
local function SetNetworkOwner(part, cframe) 
    if not part then return end 
    pcall(function() 
        if ReplicatedStorage:FindFirstChild("GrabEvents") and ReplicatedStorage.GrabEvents:FindFirstChild("SetNetworkOwner") then
            ReplicatedStorage.GrabEvents.SetNetworkOwner:FireServer(part, cframe or LocalHRP().CFrame) 
        end
    end) 
end

local function Velocity(part, vel)
    if not part or not part.Parent then return end
    local bv = Instance.new("BodyVelocity")
    bv.MaxForce = Vector3.new(1e8, 1e8, 1e8)
    bv.Velocity = vel
    bv.Parent = part
    task.delay(1, function() 
        pcall(function() bv:Destroy() end) 
    end)
end

local function MoveTo(part, targetCFrame)
    if not part or not part.Parent then return end
    for _, v in ipairs(part.Parent:GetDescendants()) do 
        if v:IsA("BasePart") then v.CanCollide = false end 
    end
    local b = Instance.new("BodyPosition")
    b.MaxForce = Vector3.new(1e8, 1e8, 1e8)
    b.Position = targetCFrame.Position
    b.P, b.D = 2e4, 5e3
    b.Parent = part
    task.spawn(function()
        task.wait(1)
        pcall(function() 
            b:Destroy() 
            for _, v in ipairs(part.Parent:GetDescendants()) do 
                if v:IsA("BasePart") then v.CanCollide = true end 
            end
        end)
    end)
end

local function ungrab(part) 
    pcall(function() 
        if ReplicatedStorage:FindFirstChild("GrabEvents") and ReplicatedStorage.GrabEvents:FindFirstChild("DestroyGrabLine") then
            ReplicatedStorage.GrabEvents.DestroyGrabLine:FireServer(part) 
        end
    end) 
end

-- ====================================================================
-- GEOMETRIC CONTROL LOGIC (線香花火用)
-- ====================================================================
local function rescanGeometricTargets()
    for _,r in ipairs(GeometricList) do if r.part then detachPhysics(r.part) end end
    GeometricList = {}
    local currentTargets = {}

    for _, d in ipairs(Workspace:GetDescendants()) do
        if d:IsA("Part") and d.Name:match(GeometricTargetName) and not d.Anchored then
            table.insert(currentTargets, {model=d.Parent or d, part=d})
        elseif d:IsA("Model") and d.Name:match(GeometricTargetName) then
            local part = d.PrimaryPart or d:FindFirstChildWhichIsA("BasePart")
            if part and not part.Anchored then table.insert(currentTargets, {model=d, part=part}) end
        end
    end
    if #currentTargets == 0 then return end
    for i, target in ipairs(currentTargets) do
        local bp, bg = attachPhysics(target.part)
        table.insert(GeometricList, {
            model=target.model,
            part=target.part,
            id=i,
            bp=bp,
            bg=bg
        })
    end
end

local function getPatternTarget(i, n, t)
    local root = LocalHRP(); if not root then return Vector3.new(0,0,0) end
    local phase = t * (RotationSpeed / 100) + (i * 2 * math.pi / n)
    local x, z, y = 0, 0, HeightOffset

    if CurrentPattern == "Circle" then
        x = Radius * math.cos(phase)
        z = Radius * math.sin(phase)
        
    elseif CurrentPattern == "Square" then
        local normalizedPhase = (phase % (2 * math.pi))
        local side = math.floor(normalizedPhase / (math.pi / 2))
        local progress = (normalizedPhase % (math.pi / 2)) / (math.pi / 2)
        
        if side == 0 then
            x = Radius
            z = -Radius + (2 * Radius * progress)
        elseif side == 1 then
            x = Radius - (2 * Radius * progress)
            z = Radius
        elseif side == 2 then
            x = -Radius
            z = Radius - (2 * Radius * progress)
        else
            x = -Radius + (2 * Radius * progress)
            z = -Radius
        end
        
    elseif CurrentPattern == "Triangle" then
        local normalizedPhase = (phase % (2 * math.pi))
        local side = math.floor(normalizedPhase / (2 * math.pi / 3))
        local progress = (normalizedPhase % (2 * math.pi / 3)) / (2 * math.pi / 3)
        
        local angles = {math.pi / 2, math.pi / 2 + 2 * math.pi / 3, math.pi / 2 + 4 * math.pi / 3}
        local x1 = Radius * math.cos(angles[side + 1])
        local z1 = Radius * math.sin(angles[side + 1])
        local x2 = Radius * math.cos(angles[(side + 1) % 3 + 1])
        local z2 = Radius * math.sin(angles[(side + 1) % 3 + 1])
        
        x = x1 + (x2 - x1) * progress
        z = z1 + (z2 - z1) * progress
        
    elseif CurrentPattern == "Pentagon" then
        local normalizedPhase = (phase % (2 * math.pi))
        local side = math.floor(normalizedPhase / (2 * math.pi / 5))
        local progress = (normalizedPhase % (2 * math.pi / 5)) / (2 * math.pi / 5)
        
        local angle1 = (side / 5) * 2 * math.pi - math.pi / 2
        local angle2 = ((side + 1) / 5) * 2 * math.pi - math.pi / 2
        
        local x1 = Radius * math.cos(angle1)
        local z1 = Radius * math.sin(angle1)
        local x2 = Radius * math.cos(angle2)
        local z2 = Radius * math.sin(angle2)
        
        x = x1 + (x2 - x1) * progress
        z = z1 + (z2 - z1) * progress
        
    elseif CurrentPattern == "Hexagon" then
        local normalizedPhase = (phase % (2 * math.pi))
        local side = math.floor(normalizedPhase / (2 * math.pi / 6))
        local progress = (normalizedPhase % (2 * math.pi / 6)) / (2 * math.pi / 6)
        
        local angle1 = (side / 6) * 2 * math.pi
        local angle2 = ((side + 1) / 6) * 2 * math.pi
        
        local x1 = Radius * math.cos(angle1)
        local z1 = Radius * math.sin(angle1)
        local x2 = Radius * math.cos(angle2)
        local z2 = Radius * math.sin(angle2)
        
        x = x1 + (x2 - x1) * progress
        z = z1 + (z2 - z1) * progress
        
    elseif CurrentPattern == "Octagon" then
        local normalizedPhase = (phase % (2 * math.pi))
        local side = math.floor(normalizedPhase / (2 * math.pi / 8))
        local progress = (normalizedPhase % (2 * math.pi / 8)) / (2 * math.pi / 8)
        
        local angle1 = (side / 8) * 2 * math.pi
        local angle2 = ((side + 1) / 8) * 2 * math.pi
        
        local x1 = Radius * math.cos(angle1)
        local z1 = Radius * math.sin(angle1)
        local x2 = Radius * math.cos(angle2)
        local z2 = Radius * math.sin(angle2)
        
        x = x1 + (x2 - x1) * progress
        z = z1 + (z2 - z1) * progress
        
    elseif CurrentPattern == "Palette" then
        local rowSize = 5
        local col = (i - 1) % rowSize
        local row = math.floor((i - 1) / rowSize)
        local baseX = (col - (rowSize-1)/2) * (Radius / 2)
        local baseZ = (row) * (Radius / 2)
        
        local rotAngle = t * (RotationSpeed / 200)
        x = baseX * math.cos(rotAngle) - baseZ * math.sin(rotAngle)
        z = baseX * math.sin(rotAngle) + baseZ * math.cos(rotAngle)
        y = HeightOffset
        
    elseif CurrentPattern == "Flower" then
        local petalPhase = phase * 5
        local r = Radius * (1 + 0.6 * math.abs(math.sin(petalPhase)))
        x = r * math.cos(phase)
        z = r * math.sin(phase)
        y = HeightOffset + math.sin(petalPhase) * 2
        
    elseif CurrentPattern == "Cloud" then
        local r = Radius * (1 + 0.3 * math.sin(phase * 3) + 0.2 * math.sin(phase * 7))
        x = r * math.cos(phase)
        z = r * math.sin(phase)
        y = HeightOffset + math.sin(t * 0.5 + i * 0.5) * 3
        
    elseif CurrentPattern == "Rainbow" then
        local angle = (i / n) * math.pi
        x = Radius * math.cos(angle) * 1.5
        y = HeightOffset + Radius * math.sin(angle)
        z = math.sin(t + i * 0.3) * 3
        
    elseif CurrentPattern == "Spiral" then
        local spiralRadius = Radius * (0.3 + 0.7 * (i / n))
        x = spiralRadius * math.cos(phase)
        z = spiralRadius * math.sin(phase)
        y = HeightOffset + (i / n) * Radius * 0.8
        
    elseif CurrentPattern == "Star" then
        local r = Radius * (1 + 0.5 * math.sin(phase * 5))
        x = r * math.cos(phase)
        z = r * math.sin(phase)
        y = HeightOffset + math.abs(math.sin(phase * 5)) * 5
        
    elseif CurrentPattern == "Heart" then
        local t_param = phase
        x = Radius * 0.8 * (16 * math.sin(t_param)^3)
        z = -Radius * 0.8 * (13 * math.cos(t_param) - 5 * math.cos(2*t_param) - 2 * math.cos(3*t_param) - math.cos(4*t_param))
        y = HeightOffset + math.sin(t * 2 + i * 0.5) * 2
        
    elseif CurrentPattern == "Butterfly" then
        local wing = math.sin(phase * 2) * Radius
        x = wing * math.cos(phase)
        z = Radius * math.sin(phase)
        y = HeightOffset + math.abs(math.sin(phase * 2)) * 4
        
    elseif CurrentPattern == "Wave" then
        local angle = (i / n) * math.pi * 4
        x = Radius * math.cos(phase)
        z = Radius * math.sin(phase)
        y = HeightOffset + math.sin(angle + t * 3) * 8
        
    elseif CurrentPattern == "Bubble" then
        local bubblePhase = phase + math.sin(t * 2 + i) * 0.5
        x = Radius * math.cos(bubblePhase)
        z = Radius * math.sin(bubblePhase)
        y = HeightOffset + math.abs(math.sin(t * 3 + i)) * 10
        
    elseif CurrentPattern == "DNA" then
        local helixPhase = (i / n) * 4 * math.pi + t * (RotationSpeed / 100)
        if i % 2 == 0 then
            x = Radius * math.cos(helixPhase)
            z = Radius * math.sin(helixPhase)
        else
            x = -Radius * math.cos(helixPhase)
            z = -Radius * math.sin(helixPhase)
        end
        y = HeightOffset + (i / n) * Radius * 1.5 - Radius * 0.75
        
    elseif CurrentPattern == "Infinity" then
        local scale = Radius / 1.5
        local t_param = phase
        x = scale * math.sin(t_param) * 2.5
        z = scale * math.sin(t_param * 2) * 1.5
        y = HeightOffset + math.sin(t + i * 0.3) * 2
        
    elseif CurrentPattern == "Tree" then
        local trunkWidth = Radius * 0.15
        local crownRadius = Radius
        local normalizedI = (i - 1) / math.max(n - 1, 1)
        
        if normalizedI < 0.25 then
            local trunkProgress = normalizedI / 0.25
            local angle = (i / n) * math.pi * 2
            x = trunkWidth * math.cos(angle)
            z = trunkWidth * math.sin(angle)
            y = HeightOffset - Radius * 0.6 + trunkProgress * Radius * 0.8
        else
            local crownProgress = (normalizedI - 0.25) / 0.75
            local layers = math.floor(crownProgress * 3)
            local layerProgress = (crownProgress * 3) % 1
            
            local crownPhase = phase + layerProgress * math.pi * 2
            local layerRadius = crownRadius * (1 - layers * 0.15)
            local r = layerRadius * (0.7 + 0.3 * math.sin(crownPhase * 4))
            
            x = r * math.cos(crownPhase)
            z = r * math.sin(crownPhase)
            y = HeightOffset + Radius * 0.2 + crownProgress * Radius * 0.7
        end
        
    elseif CurrentPattern == "Pentagram" then
        local starPoints = 5
        local outerRadius = Radius
        local innerRadius = Radius * 0.382
        
        local normalizedPhase = (phase % (2 * math.pi))
        local segment = math.floor(normalizedPhase / (2 * math.pi / (starPoints * 2)))
        local progress = (normalizedPhase % (2 * math.pi / (starPoints * 2))) / (2 * math.pi / (starPoints * 2))
        
        local function getStarPoint(index, outer)
            local angle = (index / (starPoints * 2)) * 2 * math.pi - math.pi / 2
            local r = outer and outerRadius or innerRadius
            return r * math.cos(angle), r * math.sin(angle)
        end
        
        local isOuter = (segment % 2 == 0)
        local x1, z1 = getStarPoint(segment, isOuter)
        local x2, z2 = getStarPoint(segment + 1, not isOuter)
        
        x = x1 + (x2 - x1) * progress
        z = z1 + (z2 - z1) * progress
        y = HeightOffset
        
    elseif CurrentPattern == "Sphere" then
        local goldenRatio = (1 + math.sqrt(5)) / 2
        local angleIncrement = math.pi * 2 * goldenRatio
        
        local index = (i - 1) / math.max(n - 1, 1)
        local phi = math.acos(1 - 2 * index)
        local theta = angleIncrement * (i - 1) + t * (RotationSpeed / 100)
        
        x = Radius * math.sin(phi) * math.cos(theta)
        z = Radius * math.sin(phi) * math.sin(theta)
        y = HeightOffset + Radius * math.cos(phi)
        
    elseif CurrentPattern == "Manji" then
        local armLength = Radius * 1.2
        local armWidth = Radius * 0.25
        local normalizedPhase = (phase % (2 * math.pi))
        local arm = math.floor(normalizedPhase / (math.pi / 2))
        local progress = (normalizedPhase % (math.pi / 2)) / (math.pi / 2)
        
        if arm == 0 then
            x = armLength * progress
            z = armWidth
        elseif arm == 1 then
            x = armLength
            z = armWidth - (armWidth * 2) * progress
            if progress > 0.5 then
                x = armLength - (progress - 0.5) * 2 * armLength
                z = -armWidth
            end
        elseif arm == 2 then
            x = -armLength
            z = -armWidth + (armWidth * 2) * progress
            if progress > 0.5 then
                z = armWidth
                x = -armLength + (progress - 0.5) * 2 * (armLength - armWidth)
            end
        else
            x = -armWidth + (armWidth * 2) * progress
            z = armWidth
            if progress > 0.5 then
                x = armWidth
                z = armWidth - (progress - 0.5) * 2 * armWidth
            end
        end
        y = HeightOffset + math.sin(t * 2 + phase) * 1.5
        
    elseif CurrentPattern == "Explosion" then
        local cycleDuration = 3
        local cycleTime = t % cycleDuration
        local explosionProgress = cycleTime / cycleDuration
        
        local minRadius = Radius * 0.3
        local maxRadius = Radius * 2
        local currentRadius = minRadius + (maxRadius - minRadius) * explosionProgress
        
        local goldenRatio = (1 + math.sqrt(5)) / 2
        local angleIncrement = math.pi * 2 * goldenRatio
        
        local phi = math.acos(1 - 2 * ((i - 1) / math.max(n - 1, 1)))
        local theta = angleIncrement * (i - 1) + phase
        
        x = currentRadius * math.sin(phi) * math.cos(theta)
        z = currentRadius * math.sin(phi) * math.sin(theta)
        y = HeightOffset + currentRadius * math.cos(phi) + math.sin(t * 5 + i) * 2
        
        local pulse = 1 + math.sin(t * 8 + i * 0.5) * 0.1
        x, z = x * pulse, z * pulse
    end
    
    return (root.CFrame * CFrame.new(x, y, z)).p
end

local function startGeometricLoop()
    if geometricLoopConn then geometricLoopConn:Disconnect() end
    tAccum = 0
    rescanGeometricTargets()
    if #GeometricList == 0 then IsGeometricActive = false return end

    geometricLoopConn = RunService.Heartbeat:Connect(function(dt)
        local root = LocalHRP(); if not root then return end
        tAccum += dt

        for j = #GeometricList, 1, -1 do
            local rec = GeometricList[j]
            if not rec.part or not rec.part.Parent then
                table.remove(GeometricList, j)
            else
                rec.part.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                rec.part.AssemblyAngularVelocity = Vector3.new(0, 0, 0)

                rec.bp.Position = getPatternTarget(j, #GeometricList, tAccum)
                rec.bg.CFrame = root.CFrame
            end
        end
    end)
end

-- ====================================================================
-- WING MOTION LOGIC (羽モーション用)
-- ====================================================================
local function rescanWingTargets()
    for _,r in ipairs(WingList) do if r.part then detachPhysics(r.part) end end
    WingList = {}
    local currentTargets = {}

    for _, d in ipairs(Workspace:GetDescendants()) do
        if d:IsA("Part") and d.Name:match(WingTargetName) and not d.Anchored then
            table.insert(currentTargets, {model=d.Parent or d, part=d})
        elseif d:IsA("Model") and d.Name:match(WingTargetName) then
            local part = d.PrimaryPart or d:FindFirstChildWhichIsA("BasePart")
            if part and not part.Anchored then table.insert(currentTargets, {model=d, part=part}) end
        end
    end
    if #currentTargets == 0 then return end
    for i, target in ipairs(currentTargets) do
        local bp, bg = attachPhysics(target.part)
        table.insert(WingList, {
            model=target.model,
            part=target.part,
            id=i,
            bp=bp,
            bg=bg
        })
    end
end

local function getWingPosition(i, n, t)
    local root = LocalHRP(); if not root then return Vector3.new(0,0,0) end

    local flapCycle = t * (WingSpeed / 500)
    local side = (i <= math.ceil(n/2)) and 1 or -1
    local wingIndex = (i <= math.ceil(n/2)) and i or (i - math.ceil(n/2))
    local maxWingIndex = math.ceil(n/2)
    local wingProgress = wingIndex / maxWingIndex
    local flapAmount = math.sin(flapCycle + wingProgress * math.pi) * WingSpread

    local x = side * (WingRadius * wingProgress + flapAmount * 0.5)
    local y = WingHeightOffset + math.abs(math.sin(flapCycle + wingProgress * math.pi)) * (WingSpread * 0.5)
    local z = math.sin(flapCycle * 0.5) * (WingRadius * 0.3) + (wingProgress * WingRadius * 0.2)

    return (root.CFrame * CFrame.new(x, y, z)).p
end

local function startWingLoop()
    if wingLoopConn then wingLoopConn:Disconnect() end
    tAccum = 0
    rescanWingTargets()
    if #WingList == 0 then IsWingActive = false return end

    wingLoopConn = RunService.Heartbeat:Connect(function(dt)
        local root = LocalHRP(); if not root then return end
        tAccum += dt

        for j = #WingList, 1, -1 do
            local rec = WingList[j]
            if not rec.part or not rec.part.Parent then
                table.remove(WingList, j)
            else
                rec.bp.Position = getWingPosition(j, #WingList, tAccum)
                rec.bg.CFrame = root.CFrame
            end
        end
    end)
end

-- ====================================================================
-- EGG HUB FUNCTIONS (掴み/防御/カメラ機能)
-- ====================================================================
local function updateCameraZoom()
    if EggConfig.Camera.SuperZoom then
        LP.CameraMaxZoomDistance = 50000
    else
        LP.CameraMaxZoomDistance = EggConfig.Camera.MaxZoom
    end
end

RunService.Heartbeat:Connect(function(dt)
    EggDefenseTimer = EggDefenseTimer + dt
    local root, hum = LocalHRP(), getHum()
    if not root or not hum then return end
    
    if EggDefenseTimer >= 0.1 then
        if EggConfig.Defense.AntiGrab then 
            pcall(function() 
                if ReplicatedStorage:FindFirstChild("CharacterEvents") and ReplicatedStorage.CharacterEvents:FindFirstChild("Struggle") then
                    ReplicatedStorage.CharacterEvents.Struggle:FireServer(LP) 
                end
                if ReplicatedStorage:FindFirstChild("GameCorrectionEvents") and ReplicatedStorage.GameCorrectionEvents:FindFirstChild("StopAllVelocity") then
                    ReplicatedStorage.GameCorrectionEvents.StopAllVelocity:FireServer() 
                end
            end) 
        end
        
        if EggConfig.Defense.AntiVoid and root.Position.Y < -87.5 then 
            root.CFrame = CFrame.new(0, 10, 0) 
        end
        
        if EggConfig.Defense.AntiRagdoll and hum:GetState() == Enum.HumanoidStateType.Ragdoll then 
            hum:ChangeState(Enum.HumanoidStateType.Running) 
        end
        
        EggDefenseTimer = 0
    end
    
    updateCameraZoom()
end)

Workspace.ChildAdded:Connect(function(v)
    if v.Name == "GrabParts" and v:IsA("Model") then
        local GrabPart = v:FindFirstChild("GrabPart")
        if not GrabPart then return end
        local WeldConstraint = GrabPart:FindFirstChild("WeldConstraint")
        if not WeldConstraint or not WeldConstraint.Part1 then return end
        local target = WeldConstraint.Part1
        
        v:GetPropertyChangedSignal("Parent"):Connect(function()
            if not v.Parent and target and target.Parent then
                local throwVel = Instance.new("BodyVelocity")
                throwVel.MaxForce = Vector3.new(1e8, 1e8, 1e8)
                throwVel.Velocity = Workspace.CurrentCamera.CFrame.LookVector * EggConfig.Grab.ThrowPower
                throwVel.Parent = target
                Debris:AddItem(throwVel, 0.1)
            end
        end)
        
        task.spawn(function()
            task.wait(0.1)
            
            if EggConfig.Grab.VoidGrab then 
                SetNetworkOwner(target) 
                Velocity(target, Vector3.new(0, 10000, 0)) 
            end
            
            if EggConfig.Grab.KillGrab then 
                SetNetworkOwner(target) 
                MoveTo(target, CFrame.new(4096, -75, 4096)) 
                Velocity(target, Vector3.new(0, -1000, 0)) 
            end
            
            if EggConfig.Grab.KickGrab then
                local player = Players:GetPlayerFromCharacter(target.Parent)
                if player then 
                    SetNetworkOwner(target) 
                    MoveTo(target, CFrame.new(25e25, 25e25, 25e25)) 
                    task.wait(0.5) 
                    ungrab(target) 
                end
            end
            
            if EggConfig.Grab.AnchorGrab then
                SetNetworkOwner(target)
                local pos = target.CFrame
                for _ = 1, 2 do
                    SetNetworkOwner(target)
                    local bp = Instance.new("BodyPosition")
                    bp.Position = pos.Position
                    bp.MaxForce = Vector3.new(1e8, 1e8, 1e8)
                    bp.Parent = target
                    local bg = Instance.new("BodyGyro")
                    bg.CFrame = pos
                    bg.MaxTorque = Vector3.new(1e8, 1e8, 1e8)
                    bg.Parent = target
                    task.wait(0.5)
                end
            end
        end)
    end
end)

-- ====================================================================
-- UI SETUP (OrionLib)
-- ====================================================================
local Window = OrionLib:MakeWindow({
    Name = "AKI hubb2.0",
    HidePremium = false,
    SaveConfig = true,
    IntroEnabled = false
})

-- 線香花火制御タブ
local SparklerTab = Window:MakeTab({
    Name = "スパークラー",
    Icon = "rbxassetid://6034509993",
    PremiumOnly = false
})

SparklerTab:AddToggle({
    Name = "有効化",
    Default = false,
    Callback = function(Value)
        IsGeometricActive = Value
        if Value then
            startGeometricLoop()
        else
            if geometricLoopConn then geometricLoopConn:Disconnect() end
        end
    end
})

SparklerTab:AddDropdown({
    Name = "形状選択",
    Default = "Circle",
    Options = {
        "Circle", "Square", "Triangle", "Pentagon", 
        "Hexagon", "Octagon", "Star", "Heart", 
        "Flower", "Cloud", "Rainbow", "Spiral", 
        "Butterfly", "Wave", "Bubble", "DNA", 
        "Infinity", "Palette", "Tree", "Pentagram",
        "Sphere", "Manji", "Explosion"
    },
    Callback = function(Value)
        CurrentPattern = Value
        tAccum = 0
    end
})

SparklerTab:AddSlider({
    Name = "サイズ",
    Min = 2,
    Max = 150,
    Default = 10,
    Color = Color3.fromRGB(255, 255, 255),
    Increment = 1,
    ValueName = "半径",
    Callback = function(Value)
        Radius = Value
    end
})

SparklerTab:AddSlider({
    Name = "高さ",
    Min = -100,
    Max = 100,
    Default = 5,
    Color = Color3.fromRGB(255, 255, 255),
    Increment = 1,
    ValueName = "深度",
    Callback = function(Value)
        HeightOffset = Value
    end
})

SparklerTab:AddSlider({
    Name = "回転速度",
    Min = 10,
    Max = 3000,
    Default = 1000,
    Color = Color3.fromRGB(255, 255, 255),
    Increment = 10,
    ValueName = "速度",
    Callback = function(Value)
        RotationSpeed = Value
    end
})

-- 羽モーション制御タブ
local WingTab = Window:MakeTab({
    Name = "羽モーション",
    Icon = "rbxassetid://6034509993",
    PremiumOnly = false
})

WingTab:AddToggle({
    Name = "有効化",
    Default = false,
    Callback = function(Value)
        IsWingActive = Value
        if Value then
            startWingLoop()
        else
            if wingLoopConn then wingLoopConn:Disconnect() end
        end
    end
})

WingTab:AddSlider({
    Name = "羽のサイズ",
    Min = 2,
    Max = 50,
    Default = 10,
    Color = Color3.fromRGB(255, 255, 255),
    Increment = 1,
    ValueName = "サイズ",
    Callback = function(Value)
        WingRadius = Value
    end
})

WingTab:AddSlider({
    Name = "羽の広がり",
    Min = 1,
    Max = 30,
    Default = 10,
    Color = Color3.fromRGB(255, 255, 255),
    Increment = 1,
    ValueName = "広がり",
    Callback = function(Value)
        WingSpread = Value
    end
})

WingTab:AddSlider({
    Name = "高さ",
    Min = -50,
    Max = 50,
    Default = 5,
    Color = Color3.fromRGB(255, 255, 255),
    Increment = 1,
    ValueName = "深度",
    Callback = function(Value)
        WingHeightOffset = Value
    end
})

WingTab:AddSlider({
    Name = "羽ばたき速度",
    Min = 10,
    Max = 3000,
    Default = 1000,
    Color = Color3.fromRGB(255, 255, 255),
    Increment = 10,
    ValueName = "速度",
    Callback = function(Value)
        WingSpeed = Value
    end
})

-- サイレントエイムタブ (追加)
local SilentAimTab = Window:MakeTab({
    Name = "サイレントエイム",
    Icon = "rbxassetid://6031086054",
    PremiumOnly = false
})

SilentAimTab:AddSection({
    Name = "サイレントエイム設定"
})

SilentAimTab:AddSlider({
    Name = "エイム範囲",
    Min = 5,
    Max = 100,
    Default = 30,
    Color = Color3.fromRGB(255, 255, 255),
    Increment = 1,
    ValueName = "スタッド",
    Callback = function(value)
        SilentAimRange = value
    end
})

SilentAimTab:AddToggle({
    Name = "サイレントエイムON/OFF",
    Default = false,
    Callback = function(state)
        SilentAimEnabled = state
        
        if state then
            HookSilentAim()
            OrionLib:MakeNotification({
                Name = "エイミング",
                Content = "サイレントエイム有効化",
                Time = 3
            })
        else
            OrionLib:MakeNotification({
                Name = "エイミング",
                Content = "サイレントエイム無効化",
                Time = 3
            })
        end
    end
})

SilentAimTab:AddLabel("注意: この機能はRaycastベースの武器にのみ有効です")
SilentAimTab:AddLabel("範囲内の最も近いプレイヤーを自動的にターゲットします")

-- 掴み機能タブ (Egg Hub機能)
local GrabTab = Window:MakeTab({
    Name = "掴み機能",
    Icon = "rbxassetid://6034509993",
    PremiumOnly = false
})

GrabTab:AddSection({
    Name = "掴みオプション"
})

GrabTab:AddToggle({
    Name = "キック掴み",
    Default = false,
    Callback = function(Value)
        EggConfig.Grab.KickGrab = Value
    end
})

GrabTab:AddToggle({
    Name = "キル掴み",
    Default = false,
    Callback = function(Value)
        EggConfig.Grab.KillGrab = Value
    end
})

GrabTab:AddToggle({
    Name = "奈落掴み",
    Default = false,
    Callback = function(Value)
        EggConfig.Grab.VoidGrab = Value
    end
})

GrabTab:AddToggle({
    Name = "固定掴み",
    Default = false,
    Callback = function(Value)
        EggConfig.Grab.AnchorGrab = Value
    end
})

GrabTab:AddSlider({
    Name = "投げる強さ",
    Min = 0,
    Max = 10000,
    Default = 250,
    Color = Color3.fromRGB(255, 255, 255),
    Increment = 10,
    ValueName = "強さ",
    Callback = function(Value)
        EggConfig.Grab.ThrowPower = Value
    end
})

-- 防御機能タブ
local DefenseTab = Window:MakeTab({
    Name = "防御機能",
    Icon = "rbxassetid://6034509993",
    PremiumOnly = false
})

DefenseTab:AddSection({
    Name = "防御オプション"
})

DefenseTab:AddToggle({
    Name = "アンチ掴み",
    Default = false,
    Callback = function(Value)
        EggConfig.Defense.AntiGrab = Value
    end
})

DefenseTab:AddToggle({
    Name = "アンチ奈落",
    Default = false,
    Callback = function(Value)
        EggConfig.Defense.AntiVoid = Value
    end
})

DefenseTab:AddToggle({
    Name = "アンチ爆発",
    Default = false,
    Callback = function(Value)
        EggConfig.Defense.AntiExplode = Value
    end
})

DefenseTab:AddToggle({
    Name = "アンチグッチ",
    Default = false,
    Callback = function(Value)
        EggConfig.Defense.AntiGucci = Value
    end
})

DefenseTab:AddToggle({
    Name = "アンチラグドール",
    Default = false,
    Callback = function(Value)
        EggConfig.Defense.AntiRagdoll = Value
    end
})

-- 視点設定タブ
local CameraTab = Window:MakeTab({
    Name = "視点設定",
    Icon = "rbxassetid://6034509993",
    PremiumOnly = false
})

CameraTab:AddSection({
    Name = "カメラメニュー"
})

CameraTab:AddToggle({
    Name = "50000ズーム",
    Default = false,
    Callback = function(Value)
        EggConfig.Camera.SuperZoom = Value
        updateCameraZoom()
    end
})

CameraTab:AddSlider({
    Name = "ズーム距離",
    Min = 0.5,
    Max = 50000,
    Default = 128,
    Color = Color3.fromRGB(255, 255, 255),
    Increment = 10,
    ValueName = "距離",
    Callback = function(Value)
        EggConfig.Camera.MaxZoom = Value
        updateCameraZoom()
    end
})

CameraTab:AddLabel("通常ズーム距離: 0.5 ~ 128")
CameraTab:AddLabel("50000スタッドズーム: 有効時最大50000")

-- UI初期化
OrionLib:Init()

-- OrionUIのGUI名を取得
task.wait(0.5)
for _, gui in pairs(game:GetService("CoreGui"):GetChildren()) do
    if gui:FindFirstChild("Main") or gui.Name:match("Orion") then
        orionGuiName = gui.Name
        break
    end
end

-- レインボーUI効果
RunService.Heartbeat:Connect(function()
    rainbowHue = (rainbowHue + 0.005) % 1
    local rainbowColor = Color3.fromHSV(rainbowHue, 1, 1)

    local targetGui = orionGuiName and game:GetService("CoreGui"):FindFirstChild(orionGuiName)
    if not targetGui then return end

    for _, descendant in pairs(targetGui:GetDescendants()) do
        pcall(function()
            if descendant:IsA("UIStroke") then
                descendant.Color = rainbowColor
                descendant.Transparency = 0
            end
            if descendant:IsA("Frame") then
                descendant.BorderColor3 = rainbowColor
            end
            if descendant:IsA("TextButton") then
                descendant.BorderColor3 = rainbowColor
            end
            if descendant:IsA("TextLabel") then
                descendant.BorderColor3 = rainbowColor
            end
            if descendant:IsA("ScrollingFrame") then
                descendant.BorderColor3 = rainbowColor
            end
        end)
    end
end)

-- 初期化
LP.CameraMode = Enum.CameraMode.Classic
LP.CameraMinZoomDistance = 0.5
updateCameraZoom()

-- サイレントエイムフック初期化
task.spawn(function()
    task.wait(2)
    HookSilentAim()
end)

print("smilehub1.0 が読み込まれました！")
print("機能: スパークラー制御、羽モーション、サイレント、Egg Hub機能統合")
print("タブ: スパークラー、羽モーション、サイレントエイム、掴み機能、防御機能、カメラ設定")
